(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.9
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- *)

unit example;

{$mode objfpc}{$H+}

{$define example_FUNCTION_WRAPPER}
{$define example_CLASS_WRAPPER}

interface

uses 

// interface_uses


     Classes,
     SysUtils;


// interface_uses



// interface_type_begin 


//pasraw_intf.f

type
  CPVector = pointer;

type
  CPVectorArray = pointer;

// interface_type_end 



// interface_functions

  function New_Vector( x,  y, z:Double ):CPVector; stdcall;

  procedure Delete_Vector( self:CPVector ); stdcall;

  function Vector_print( self:CPVector ):PChar; stdcall;

  function Addv(  a, b:CPVector ):CPVector; stdcall;

  function New_VectorArray(maxsize:Integer ):CPVectorArray; stdcall;

  procedure Delete_VectorArray( self:CPVectorArray ); stdcall;

  function VectorArray_size( self:CPVectorArray ):Integer; stdcall;

  function VectorArray__get( self:CPVectorArray; index:Integer ):CPVector; stdcall;

  procedure VectorArray__set( self:CPVectorArray; index:Integer;  a:CPVector ); stdcall;

{$ifdef example_FUNCTION_WRAPPER}

// interface_functions_wrapper

{$endif} //example_FUNCTION_WRAPPER

{$ifdef example_CLASS_WRAPPER}

type

  TVector = class (TObject)

    private
      FCObjPtr : CPVector;
      FOwnCObjPtr : boolean;
    
    protected
      procedure SetCObjPtr(Value : CPVector);
    
    public

    constructor Create; overload; virtual;
    constructor Create(CObjPtr:CPVector; OwnObj:boolean); overload; 

    constructor Create ( x: Double;  y: Double;  z: Double);overload; 

    function print (): PChar;

    destructor Destroy; override;

  //various other methods
  
  public  
    property CObjPtr : CPVector read FCObjPtr write SetCObjPtr;
    property OwnCObjPtr : boolean read FOwnCObjPtr  write FOwnCObjPtr ;
  //proxy class methods
  end; {TVector}

  TVectorArray = class (TObject)

    private
      FCObjPtr : CPVectorArray;
      FOwnCObjPtr : boolean;
    
    protected
      procedure SetCObjPtr(Value : CPVectorArray);
    
    public

    constructor Create; overload; virtual;
    constructor Create(CObjPtr:CPVectorArray; OwnObj:boolean); overload; 

    constructor Create ( maxsize: Integer);overload; 

    function size (): Integer;

    function _get ( index: Integer): TVector;

    procedure _set ( index: Integer; var a: TVector);

    destructor Destroy; override;

  //various other methods
  
  public  
    property CObjPtr : CPVectorArray read FCObjPtr write SetCObjPtr;
    property OwnCObjPtr : boolean read FOwnCObjPtr  write FOwnCObjPtr ;
  //proxy class methods
  end; {TVectorArray}

{$endif} //example_CLASS_WRAPPER
// Output a Pascal type wrapper class for each SWIG type
implementation


// implementation_type_begin



// implementation_uses

// implementation_type_end

// implementation_functions

{$IFDEF LINUX}
{$linklib libexample.so}
const __WRAPDLLNAME= 'libexample_wrap.so';
{$ENDIF}

{$IFDEF MSWINDOWS}
{$linklib example.dll}
const __WRAPDLLNAME= 'example_wrap.dll';
{$ENDIF}

{$IFDEF HAIKU}
{$linklib libexample.so}
const __WRAPDLLNAME= 'libexample_wrap.so';
{$ENDIF}

{$IFDEF QTOPIA}
{$linklib libexample.so}
const __WRAPDLLNAME= 'libexample_wrap.so';
{$ENDIF}

{$IFDEF DARWIN}
{$linklib example}
const __WRAPDLLNAME= '';
{$LINKFRAMEWORK example}
{$ENDIF}
 


  function New_Vector( x,  y, z:Double ):CPVector; stdcall; external __WRAPDLLNAME name 'new_Vector';

  procedure Delete_Vector( self:CPVector ); stdcall; external __WRAPDLLNAME name 'delete_Vector';

  function Vector_print( self:CPVector ):PChar; stdcall; external __WRAPDLLNAME name 'Vector_print';

  function Addv(  a, b:CPVector ):CPVector; stdcall; external __WRAPDLLNAME name '__addv';

  function New_VectorArray(maxsize:Integer ):CPVectorArray; stdcall; external __WRAPDLLNAME name 'new_VectorArray';

  procedure Delete_VectorArray( self:CPVectorArray ); stdcall; external __WRAPDLLNAME name 'delete_VectorArray';

  function VectorArray_size( self:CPVectorArray ):Integer; stdcall; external __WRAPDLLNAME name 'VectorArray_size';

  function VectorArray__get( self:CPVectorArray; index:Integer ):CPVector; stdcall; external __WRAPDLLNAME name 'VectorArray__get';

  procedure VectorArray__set( self:CPVectorArray; index:Integer;  a:CPVector ); stdcall; external __WRAPDLLNAME name 'VectorArray__set';

{$ifdef example_FUNCTION_WRAPPER}

// implementation_functions_wrapper

{$endif} //example_FUNCTION_WRAPPER

{$ifdef example_CLASS_WRAPPER}

constructor TVector.Create ( x: Double;  y: Double;  z: Double);
begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_Vector(x, y, z);
end;

function TVector.print (): PChar;
begin
  assert(FCObjPtr <> nil);
  Result := example.Vector_print(Self.FCObjPtr) ;
end;

constructor TVector.Create; 
begin
  inherited Create;
  FCObjPtr := nil;
  FOwnCObjPtr := true
end;

constructor TVector.Create(CObjPtr:CPVector; OwnObj:boolean); 
begin
  inherited Create;
  FCObjPtr := CObjPtr;
  FOwnCObjPtr := OwnObj
end;


destructor TVector.Destroy; 
begin   
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_Vector(FCObjPtr);
    FOwnCObjPtr := false;
  end;
  FCObjPtr := nil; 
  inherited Destroy;
end;

procedure TVector.SetCObjPtr(Value : CPVector);
begin
  if (Value <> FCObjPtr) then begin
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_Vector(FCObjPtr);
  end;
  FCObjPtr := Value;
  end;
end;


constructor TVectorArray.Create ( maxsize: Integer);
begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_VectorArray(maxsize);
end;

function TVectorArray.size (): Integer;
begin
  assert(FCObjPtr <> nil);
  Result := example.VectorArray_size(Self.FCObjPtr) ;
end;

function TVectorArray._get ( index: Integer): TVector;
begin
  assert(FCObjPtr <> nil);
 
    Result := TVector.Create(example.VectorArray__get(Self.FCObjPtr, index), false);
;
end;

procedure TVectorArray._set ( index: Integer; var a: TVector);
var arg2 : CPVector;
begin
  assert(FCObjPtr <> nil);
  arg2 := a.CObjPtr;
 example.VectorArray__set(Self.FCObjPtr, index, arg2);
  a.CObjPtr := arg2 ;
end;

constructor TVectorArray.Create; 
begin
  inherited Create;
  FCObjPtr := nil;
  FOwnCObjPtr := true
end;

constructor TVectorArray.Create(CObjPtr:CPVectorArray; OwnObj:boolean); 
begin
  inherited Create;
  FCObjPtr := CObjPtr;
  FOwnCObjPtr := OwnObj
end;


destructor TVectorArray.Destroy; 
begin   
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_VectorArray(FCObjPtr);
    FOwnCObjPtr := false;
  end;
  FCObjPtr := nil; 
  inherited Destroy;
end;

procedure TVectorArray.SetCObjPtr(Value : CPVectorArray);
begin
  if (Value <> FCObjPtr) then begin
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_VectorArray(FCObjPtr);
  end;
  FCObjPtr := Value;
  end;
end;


{$endif} //example_CLASS_WRAPPER

initialization


// constant_initialization

// initialization


finalization

// finalization


end.
