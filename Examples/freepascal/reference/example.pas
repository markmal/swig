(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.9
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- *)

unit example;

{$mode objfpc}{$H+}
{$define example_FUNCTION_WRAPPER}

{$define example_CLASS_WRAPPER}

interface

uses 

uses swigtypes;

     Classes,
     SysUtils;


uses swigtypes;


//interface_type_begin

//pasraw_intf.f

type

Vector = class;

type

VectorArray = class;

//interface_type_end


  function New_Vector (x, y, z: Double): Vector; stdcall;

  procedure Delete_Vector ( self: Vector); stdcall;

  function Vector_print ( self: Vector): PChar; stdcall;

  function Addv ( a, b: Vector): Vector; stdcall;

  function New_VectorArray (maxsize: Integer): VectorArray; stdcall;

  procedure Delete_VectorArray ( self: VectorArray); stdcall;

  function VectorArray_size ( self: VectorArray): Integer; stdcall;

  function VectorArray__get ( self: VectorArray;
index: Integer): Vector; stdcall;

  procedure VectorArray__set ( self: VectorArray;
index: Integer;
 a: Vector); stdcall;

{$ifdef example_CLASS_WRAPPER}

type
  Vector = class 	FCObjPtr : pointer;
	FOwnCObjPtr : boolean;

    constructor Create ( x: Double;  y: Double;  z: Double);overload; 

    function print (): PChar;
  // tm_def:
  // no desstructor
  //various other methods
  //proxy class methods
  end;  VectorArray = class 	FCObjPtr : pointer;
	FOwnCObjPtr : boolean;

    constructor Create ( maxsize: Integer);overload; 

    function size (): Integer;

    function _get ( index: Integer): TVector;

    procedure _set ( index: Integer; var a: TVector);
  // tm_def:
  // no desstructor
  //various other methods
  //proxy class methods
  end;
{$endif} //example_CLASS_WRAPPER

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER
// Output a Pascal type wrapper class for each SWIG type
implementation


{$IFDEF LINUX}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF MSWINDOWS}
const __DLLNAME= 'example.dll';


const __WRAPDLLNAME= 'example.dll';


{$ENDIF}
{$IFDEF HAIKU}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF QTOPIA}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF DARWIN}
const __DLLNAME= '';


const __WRAPDLLNAME= '';


{$LINKFRAMEWORK example}
{$ENDIF}
  function New_Vector (x, y, z: Double): Vector; stdcall; external __DLLNAME name 'new_Vector';

  procedure Delete_Vector ( self: Vector); stdcall; external __DLLNAME name 'delete_Vector';

  function Vector_print ( self: Vector): PChar; stdcall; external __DLLNAME name 'Vector_print';

  function Addv ( a, b: Vector): Vector; stdcall; external __DLLNAME name 'addv';

  function New_VectorArray (maxsize: Integer): VectorArray; stdcall; external __DLLNAME name 'new_VectorArray';

  procedure Delete_VectorArray ( self: VectorArray); stdcall; external __DLLNAME name 'delete_VectorArray';

  function VectorArray_size ( self: VectorArray): Integer; stdcall; external __DLLNAME name 'VectorArray_size';

  function VectorArray__get ( self: VectorArray;
index: Integer): Vector; stdcall; external __DLLNAME name 'VectorArray__get';

  procedure VectorArray__set ( self: VectorArray;
index: Integer;
 a: Vector); stdcall; external __DLLNAME name 'VectorArray__set';

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER

{$ifdef example_CLASS_WRAPPER}

constructor Vector.Create ( x: Double;  y: Double;  z: Double);begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_Vector(x, y, z);
end;

function Vector.print (): PChar;begin
  assert(FCObjPtr <> nil);
  Result := example.Vector_print(Self.FCObjPtr) ;
end;
  // no desstructor
constructor VectorArray.Create ( maxsize: Integer);begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_VectorArray(maxsize);
end;

function VectorArray.size (): Integer;begin
  assert(FCObjPtr <> nil);
  Result := example.VectorArray_size(Self.FCObjPtr) ;
end;

function VectorArray._get ( index: Integer): TVector;begin
  assert(FCObjPtr <> nil);
 
    Result := TVector.Create(example.VectorArray__get(Self.FCObjPtr, index), false);
;
end;

procedure VectorArray._set ( index: Integer; var a: TVector);var arg2:Vector;
begin
  assert(FCObjPtr <> nil);
  arg2 := a.CObjPtr;
 example.VectorArray__set(Self.FCObjPtr, index, arg2);
  a.CObjPtr := arg2 ;
end;
  // no desstructor
{$endif} //example_CLASS_WRAPPER

initialization



// constant initialization



//initialization


finalization


//finalization


end.
