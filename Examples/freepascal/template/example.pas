(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.9
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- *)

unit example;

{$mode objfpc}{$H+}
{$define example_FUNCTION_WRAPPER}

{$define example_CLASS_WRAPPER}

interface

uses 

uses swigtypes;

     Classes,
     SysUtils;


uses swigtypes;


//interface_type_begin

//pasraw_intf.f

type

vecint = class;

//interface_type_end


  function maxint (a, b: Integer): Integer; stdcall;

  function maxdouble (a, b: Double): Double; stdcall;

  function New_vecint (_sz: Integer): vecint; stdcall;

  function Vecint_get ( self: vecint;
index: Integer): PInteger; stdcall;

  procedure Vecint__set ( self: vecint;
index: Integer;
 val: Integer); stdcall;

  function Vecint_getitem ( self: vecint;
index: Integer): Integer; stdcall;

  procedure Vecint_setitem ( self: vecint;
index, val: Integer); stdcall;

  procedure Delete_vecint ( self: vecint); stdcall;

{$ifdef example_CLASS_WRAPPER}

type
  vecint = class 	FCObjPtr : pointer;
	FOwnCObjPtr : boolean;

    constructor Create ( _sz: Integer);overload; 

    function get ( index: Integer): PInteger;

    procedure _set ( index: Integer; var val: Integer);

    function getitem ( index: Integer): Integer;

    procedure setitem ( index: Integer;  val: Integer);
  // tm_def:
  // no desstructor
  //various other methods
  //proxy class methods
  end;
{$endif} //example_CLASS_WRAPPER

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER
// Output a Pascal type wrapper class for each SWIG type
implementation


{$IFDEF LINUX}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF MSWINDOWS}
const __DLLNAME= 'example.dll';


const __WRAPDLLNAME= 'example.dll';


{$ENDIF}
{$IFDEF HAIKU}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF QTOPIA}
const __DLLNAME= 'libexample.so';


const __WRAPDLLNAME= 'libexample.so';


{$ENDIF}
{$IFDEF DARWIN}
const __DLLNAME= '';


const __WRAPDLLNAME= '';


{$LINKFRAMEWORK example}
{$ENDIF}
  function maxint (a, b: Integer): Integer; stdcall; external __DLLNAME name 'maxint';

  function maxdouble (a, b: Double): Double; stdcall; external __DLLNAME name 'maxdouble';

  function New_vecint (_sz: Integer): vecint; stdcall; external __DLLNAME name 'new_vecint';

  function Vecint_get ( self: vecint;
index: Integer): PInteger; stdcall; external __DLLNAME name 'vecint_get';

  procedure Vecint__set ( self: vecint;
index: Integer;
 val: Integer); stdcall; external __DLLNAME name 'vecint__set';

  function Vecint_getitem ( self: vecint;
index: Integer): Integer; stdcall; external __DLLNAME name 'vecint_getitem';

  procedure Vecint_setitem ( self: vecint;
index, val: Integer); stdcall; external __DLLNAME name 'vecint_setitem';

  procedure Delete_vecint ( self: vecint); stdcall; external __DLLNAME name 'delete_vecint';

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER

{$ifdef example_CLASS_WRAPPER}

constructor vecint.Create ( _sz: Integer);begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_vecint(_sz);
end;

function vecint.get ( index: Integer): PInteger;begin
  assert(FCObjPtr <> nil);
  Result := example.Vecint_get(Self.FCObjPtr, index) ;
end;

procedure vecint._set ( index: Integer; var val: Integer);
begin
  assert(FCObjPtr <> nil);

 example.Vecint__set(Self.FCObjPtr, index, val);

end;

function vecint.getitem ( index: Integer): Integer;begin
  assert(FCObjPtr <> nil);
  Result := example.Vecint_getitem(Self.FCObjPtr, index) ;
end;

procedure vecint.setitem ( index: Integer;  val: Integer);begin
  assert(FCObjPtr <> nil);
 example.Vecint_setitem(Self.FCObjPtr, index, val);
end;
  // no desstructor
{$endif} //example_CLASS_WRAPPER

initialization



// constant initialization



//initialization


finalization


//finalization


end.
