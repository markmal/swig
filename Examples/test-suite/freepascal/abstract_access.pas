(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.9
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- *)

unit abstract_access;

{$mode objfpc}{$H+}
{$define abstract_access_FUNCTION_WRAPPER}

{$define abstract_access_CLASS_WRAPPER}

interface



uses swigtypes;


//interface_type_begin

//pasraw_intf.f

type

A = class;

type

B = class;

type

C = class;

type

D = class;

//interface_type_end


  procedure Delete_A ( self: A); stdcall;

  function A_z ( self: A): Integer; stdcall;

  function A_do_x ( self: A): Integer; stdcall;

  procedure Delete_B ( self: B); stdcall;

  procedure Delete_C ( self: C); stdcall;

  function New_D (): D; stdcall;

  procedure Delete_D ( self: D); stdcall;

{$ifdef abstract_access_CLASS_WRAPPER}

type

  TA = class (TObject, IUnknown)

  private
    FCObjPtr : A;
    FOwnCObjPtr : boolean;

  protected
	procedure SetCObjPtr(Value : A);
  // IUnknown
    function _AddRef : integer; stdcall;
    function _Release: integer; stdcall;
    function QueryInterface(const GUID:TGUID; out Intf): HRESULT; stdcall;
 public
  A = class 	FCObjPtr : pointer;
	FOwnCObjPtr : boolean;

    constructor Create; overload; virtual;
    constructor Create(CObj:A; OwnObj:boolean); overload; 

    function z (): Integer;virtual; 

    function do_x (): Integer;
  // tm_def:
    destructor Destroy; override;


    destructor Destroy; override;

  //various other methods
  
  public  
    property CObjPtr : A read FCObjPtr write SetCObjPtr;
    property OwnCObjPtr : boolean read FOwnCObjPtr  write FOwnCObjPtr ;
  //proxy class methods
  end;
  TB = class (TA) 
  public
  B = class (A)
  // tm_def:
    destructor Destroy; override;


    destructor Destroy; override;

  //various other methods
  //proxy class methods
  end;
  TC = class (TB) 
  public
  C = class (B)
  // tm_def:
    destructor Destroy; override;


    destructor Destroy; override;

  //various other methods
  //proxy class methods
  end;
  TD = class (TC) 
  public
  D = class (C)

    constructor Create ();overload; 
  // tm_def:
    destructor Destroy; override;


    destructor Destroy; override;

  //various other methods
  //proxy class methods
  end;
{$endif} //abstract_access_CLASS_WRAPPER

{$ifdef abstract_access_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //abstract_access_FUNCTION_WRAPPER
// Output a Pascal type wrapper class for each SWIG type
implementation


{$IFDEF LINUX}
const __DLLNAME= 'libabstract_access.so';


const __WRAPDLLNAME= 'libabstract_access.so';


{$ENDIF}
{$IFDEF MSWINDOWS}
const __DLLNAME= 'abstract_access.dll';


const __WRAPDLLNAME= 'abstract_access.dll';


{$ENDIF}
{$IFDEF HAIKU}
const __DLLNAME= 'libabstract_access.so';


const __WRAPDLLNAME= 'libabstract_access.so';


{$ENDIF}
{$IFDEF QTOPIA}
const __DLLNAME= 'libabstract_access.so';


const __WRAPDLLNAME= 'libabstract_access.so';


{$ENDIF}
{$IFDEF DARWIN}
const __DLLNAME= '';


const __WRAPDLLNAME= '';


{$LINKFRAMEWORK abstract_access}
{$ENDIF}
  procedure Delete_A ( self: A); stdcall; external __DLLNAME name 'delete_A';

  function A_z ( self: A): Integer; stdcall; external __DLLNAME name 'A_z';

  function A_do_x ( self: A): Integer; stdcall; external __DLLNAME name 'A_do_x';

  procedure Delete_B ( self: B); stdcall; external __DLLNAME name 'delete_B';

  procedure Delete_C ( self: C); stdcall; external __DLLNAME name 'delete_C';

  function New_D (): D; stdcall; external __DLLNAME name 'new_D';

  procedure Delete_D ( self: D); stdcall; external __DLLNAME name 'delete_D';

{$ifdef abstract_access_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //abstract_access_FUNCTION_WRAPPER

{$ifdef abstract_access_CLASS_WRAPPER}

function A.z (): Integer;begin
  assert(FCObjPtr <> nil);
  Result := abstract_access.A_z(Self.FCObjPtr) ;
end;

function A.do_x (): Integer;begin
  assert(FCObjPtr <> nil);
  Result := abstract_access.A_do_x(Self.FCObjPtr) ;
end;


function TA._AddRef : integer;
begin
   Result := -1;
end;

function TA._Release: integer;
begin
   Result := -1;
end;

function TA.QueryInterface(const GUID:TGUID; out Intf): HRESULT;
begin
   if GetInterface(GUID, Intf) then
      Result := S_OK
   else
      Result := S_FALSE	;
end;

constructor TA.Create; 
begin
  inherited Create;
  FCObjPtr := nil;
  FOwnCObjPtr := true
end;

constructor TA.Create(CObj:A; OwnObj:boolean); 
begin
  inherited Create;
  FCObjPtr := CObj;
  FOwnCObjPtr := OwnObj
end;


destructor TA.Destroy; 
begin   
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    abstract_access.delete_A(FCObjPtr);
    FOwnCObjPtr := false;
  end;
  FCObjPtr := nil; 
  inherited Destroy;
end;

procedure TA.SetCObjPtr(Value : A);
begin
  if (Value <> FCObjPtr) then begin
	if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
		abstract_access.delete_A(FCObjPtr);
	end;
	FCObjPtr := Value;
  end;
end;


destructor TB.Destroy;
begin   
  if (FCObjPtr  <> nil) and  FOwnCObjPtr then begin 
    abstract_access.delete_B(FCObjPtr);
    FOwnCObjPtr := false;
  end;  
  FCObjPtr := nil; 
  inherited Destroy;
end;


destructor TC.Destroy;
begin   
  if (FCObjPtr  <> nil) and  FOwnCObjPtr then begin 
    abstract_access.delete_C(FCObjPtr);
    FOwnCObjPtr := false;
  end;  
  FCObjPtr := nil; 
  inherited Destroy;
end;


constructor D.Create ();begin
  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := abstract_access.New_D();
end;

destructor TD.Destroy;
begin   
  if (FCObjPtr  <> nil) and  FOwnCObjPtr then begin 
    abstract_access.delete_D(FCObjPtr);
    FOwnCObjPtr := false;
  end;  
  FCObjPtr := nil; 
  inherited Destroy;
end;


{$endif} //abstract_access_CLASS_WRAPPER

initialization



// constant initialization



//initialization


finalization


//finalization


end.
